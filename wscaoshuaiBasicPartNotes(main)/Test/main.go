package main

//package main//一个测试程序不会被放在main主函数里面
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//传统方式解决测试：
//1.不方便，需要修改mian函数
//2.不利于管理，多个函数的情况下，无法统一测试，需要单独测试
//3.利用golang内的testing框架就可以解决(轻量级)，既可以单元测试，可以性能测试
// func addUppper(n int) int {
// 	res := 0
// 	for i := 1; i <= n; i++ {
// 		res += i
// 	}
// 	return res
// }
// func main() {
// 	res := addUppper(10)
// 	if res != 55 {
// 		fmt.Printf("addUpper错误，返回值=%v 期望值=%v\n", res, 55)
// 	} else {
// 		fmt.Printf("addUpper正确，返回值=%v 期望值=%v\n", res, 55)
// 	}
// }
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Golang单元测试:

func main() {

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//单元测试总结：！！！！！
//1.测试用例文件以，XXX——test.go结尾，例如cal_test.go，其中cal不是国定的
//2、测试用例函数必须以Test开头，一般来说就是Test+被测试的函数名，例如Test——AddUpper
//3.TestAddUpper(t *testing.T)的形参类型必须是*Testing.T
//4.一个测试用例文件中，可以有多个测试用例函数，比如TestAddUpper，TestSub
//5.cmd:go test (正确无日志，错误有日志)，cmd:go test -v(正确或者错误，都有日志)
//6.当出现错误时，可以使用t.Fatalf来格式化输出错误信息，并且退出程序
//7.t.Ligf方法可以输出相应的日志
//8.测试用例函数，并没有放在main函数中，也执行了，这就是测试用例的方便之处
//9.PASS表示测试用例运行测试成功，FAll表示测试用例运行失败
//10.测试单个[文件]，一定要带上被测试的源文件(go test -v cal_test.go cal.go)
//11.测试单个[方法](go test-v -test.run TestAddUpper)
